# 3D模型动画基本原理和分类

动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到

- **Morph（变形）动画：**

  直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置

- **关节动画：**

  关节动画的模型不是一个整体的Mesh,而是分成很多部分(Mesh)，通过一个父子层次结构将这些分散的Mesh组织在一起，父Mesh带动其下子Mesh的运动，各Mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。动画帧中设置各子Mesh相对于其父Mesh的变换（主要是旋转，当然也可包括移动和缩放），通过子到父，一级级的变换累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。关节动画的问题是，各部分Mesh中的顶点是固定在其Mesh坐标系中的，这样在两个Mesh结合处就可能产生裂缝。

- **骨骼蒙皮动画(SkinnedMesh**）

  骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其父骨骼，并由动画关键帧数据驱动。一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。

# SkinnedMesh原理和结构分析

SkinnedMesh中文一般称作骨骼蒙皮动画，正如其名，这种动画中包含骨骼（Bone）和蒙皮(Skinned Mesh)两个部分，Bone的层次结构和关节动画类似，Mesh则和关节动画不同：关节动画中是使用多个分散的Mesh,而Skinned Mesh中Mesh是一个整体，也就是说只有一个Mesh,实际上如果没有骨骼让Mesh运动变形，Mesh就和静态模型一样了。Skinned Mesh技术的精华在于蒙皮，所谓的皮并不是模型的贴图（也许会有人这么想过吧），而是Mesh本身，蒙皮是指将Mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样在关节处的顶点由于同时受到父子骨骼的拉扯而改变位置就消除了裂缝。Skinned Mesh这个词从字面上理解似乎是有皮的模型，哦，如果贴图是皮，那么普通静态模型不也都有吗？所以我觉得应该理解为具有蒙皮信息的Mesh或可当做皮肤用的Mesh，这个皮肤就是Mesh。而为了有皮肤功能，Mesh还需要蒙皮信息，即Skin数据，没有Skin数据就是一个普通的静态Mesh了。Skin数据决定顶点如何绑定到骨骼上。顶点的Skin数据包括顶点受哪些骨骼影响以及这些骨骼影响该顶点时的权重(weight)，另外对于每块骨骼还需要骨骼偏移矩阵(BoneOffsetMatrix)用来将顶点从Mesh空间变换到骨骼空间。在本文中，提到骨骼动画中的Mesh特指这个皮肤Mesh，提到模型是指骨骼动画模型整体。骨骼控制蒙皮运动，而骨骼本身的运动呢？当然是动画数据了。每个关键帧中包含时间和骨骼运动信息，运动信息可以用一个矩阵直接表示骨骼新的变换，也可用四元数表示骨骼的旋转，也可以随便自己定义什么只要能让骨骼动就行。除了使用编辑设定好的动画帧数据，也可以使用物理计算对骨骼进行实时控制。

### 理解骨骼和骨骼层次结构（Bone Hierarchy）

**首先要明确一个观念：骨骼决定了模型整体在世界坐标系中的位置和朝向。**

先看看静态模型吧，静态模型没有骨骼，我们在世界坐标系中放置静态模型时，只要指定模型自身坐标系在世界坐标系中的位置和朝向。在骨骼动画中，不是把Mesh直接放到世界坐标系中，Mesh只是作为Skin使用的，是依附于骨骼的，真正决定模型在世界坐标系中的位置和朝向的是骨骼。在渲染静态模型时，由于模型的顶点都是定义在模型坐标系中的，所以各顶点只要经过模型坐标系到世界坐标系的变换后就可进行渲染。而对于骨骼动画，我们设置模型的位置和朝向，实际是在设置根骨骼的位置和朝向，然后根据骨骼层次结构中父子骨骼之间的变换关系计算出各个骨骼的位置和朝向，然后根据骨骼对Mesh中顶点的绑定计算出顶点在世界坐标系中的坐标，从而对顶点进行渲染。要记住，在骨骼动画中，骨骼才是模型主体，Mesh不过是一层皮，一件衣服。

**请看第二个观念：骨骼可理解为一个坐标空间。**

骨骼只是一个形象的说法，实际上骨骼可理解为一个坐标空间，关节可理解为骨骼坐标空间的原点。关节的位置由它在父骨骼坐标空间中的位置描述。上图中有三块骨骼，分别是上臂，前臂和两个手指。Clavicle(锁骨)是一个关节，它是上臂的原点，同样肘关节(elbow joint)是前臂的原点，腕关节(wrist)是手指骨骼的原点。关节既决定了骨骼空间的位置，又是骨骼空间的旋转和缩放中心。为什么用一个4X4矩阵就可以表达一个骨骼，因为4X4矩阵中含有的平移分量决定了关节的位置，旋转和缩放分量决定了骨骼空间的旋转和缩放。我们来看前臂这个骨骼，其原点位置是位于上臂上某处的，对于上臂来说，它知道自己的坐标空间某处（即肘关节所在的位置）有一个子空间，那就是前臂，至于前臂里面是啥就不考虑了。当前臂绕肘关节旋转时，实际是前臂坐标空间在旋转，从而其中包含的子空间也在绕肘关节旋转，在这个例子中是finger骨骼。和实际生物骨骼不同的是，我们这里的骨骼并没有实质的骨头，所以前臂旋转时，他自己没啥可转的，改变的只是坐标空间的朝向。你可以说上图的蓝线在转，但实际蓝线并不存在，蓝线只是画上去表示骨骼之间关系的，真正转的是骨骼空间，我们能看到在转的是wrist joint，也就是两个finger骨骼的坐标空间，因为他们是子空间，会跟随父空间运动，就好比人跟着地球转一样。

骨骼就是坐标空间，骨骼层次就是嵌套的坐标空间。关节只是描述骨骼的位置即骨骼自己的坐标空间原点在其父空间中的位置，绕关节旋转是指骨骼坐标空间（包括所有子空间）自身的旋转，如此理解足矣。但还有两个可能的疑问，一是骨骼的长度问题，由于骨骼是坐标空间，没有所谓的长度和宽度的限制，我们看到的长度一方面是蒙皮后的结果，另一方面子骨骼的原点（也就是关节）的位置往往决定了视觉上父骨骼的长度，比如这里upper arm线段的长度实际是由elbow joint的位置决定的。第二个问题，手指的那个端点是啥啊？实际上在我们的例子中手指没有子骨骼，所以那个端点并不存在：）那是为了方便演示画上去的。实际问题中总有最下层的骨骼，他们不能决定其他骨骼了，他们的作用只剩下控制Mesh顶点。对了，那么手指的长度如何确定？我们看到的长度应该是由蒙皮决定的，也就是由Mesh中属于手指的那些点离腕关节的距离决定。

但是为什么要将骨骼组织成层次结构呢？答案是为了做动画方便，设想如果只有一块骨骼，那么让他动起来就太简单了，动画每一帧直接指定他的位置即可。如果是n块呢？通过组成一个层次结构，就可以通过父骨骼控制子骨骼的运动，牵一发而动全身，改变某骨骼时并不需要设置其下子骨骼的位置，子骨骼的位置会通过计算自动得到。上文已经说过，父子骨骼之间的关系可以理解为，子骨骼位于父骨骼的坐标系中。我们知道物体在坐标系中可以做平移变换，以及自身的旋转和缩放变换。子骨骼在父骨骼的坐标系中也可以做这些变换来改变自己在其父骨骼坐标系中的位置和朝向等。那么如何表示呢？由于4X4矩阵可以同时表示上述三种变换，所以一般描述骨骼在其父骨骼坐标系中的变换时使用一个矩阵，也就是DirectXSkinned Mesh中的Frame TransformMatrix。实际上这不是唯一的方法，但应该是公认的方法，因为矩阵不光可以同时表示多种变换还可以方便的通过连乘进行变换的组合，这在层次结构中非常方便。在本文的例子-最简单的skinned mesh实例中，我只演示了平移变换，所以只用一个3d坐标就可以表示子骨骼在父骨骼中的位置。



```c#
#defineMAX_BONE_PER_VERTEX 4   //用来设置可同时影响该顶点的最大骨骼数
class Vertex{
	int indeces;   
	vertor3 vertex; //模型空间位置
    //SkinInfo  蒙皮信息
	int _boneNum; //影响该顶点的骨骼数目
	mat4[] u_Bones; //指向这些骨骼的矩阵
	float[] u_Weights //这些骨骼作用于该点的权重
}

蒙皮的转换过程伪代码：
    BoneOffsetMatrix:每块骨骼还需要骨骼偏移矩阵(BoneOffsetMatrix)用来将顶点从Mesh空间变换到骨骼空间
    MeshVertex(mesh space) -> (BoneOffsetMatrix * vertex)  ->Bone space
    ->(BoneCombinedTransformMatrix) -> world space
        
    mat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;
    skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;
	skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;
	skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;
	//最后将模型空间变换到骨骼空间
	position=skinTransform*a_Position;

```

需要首先将模型顶点从模型空间变换到某块骨骼自身的骨骼空间，然后才能利用骨骼的世界变换计算顶点的世界坐标。BoneOffset Matrix的作用正是将模型从顶点空间变换到骨骼空间。那么Bone Offset Matrix如何得到呢？下面具体分析：

Mesh space是建模时使用的空间，mesh中顶点的位置相对于这个空间的原点定义。比如在3d max中建模时（视xy平面为地面，+z朝上），可将模型两脚之间的中点作为Mesh空间的原点，并将其放置在世界原点，这样左脚上某一顶点坐标是（10，10，2），右脚上对称的一点坐标是（-10，10，2），头顶上某一顶点的坐标是（0，0，170）。由于此时Mesh空间和世界空间重合，上述坐标既在Mesh空间也在世界空间，换句话说，此时实际是以世界空间作为Mesh空间了。在骨骼动画中，在世界中放置的是骨骼而不是Mesh，所以这个区别并不重要。在3d max中添加骨骼的时候，也是将骨骼放入世界空间中，并调整骨骼的相对位置使得和mesh相吻合（即设置骨骼的TransformMatrix），得到骨架的初始姿势以及相应的Transform Matrix(按惯例模型做成两臂侧平举直立，骨骼也要适合这个姿态)。由于骨骼的TransformMatrix（作用是将顶点从骨骼空间变换到上层空间）是基于其父骨骼空间的，只有根骨骼的Transform是基于世界空间的，所以要通过自下而上一层层Transform变换（如果使用行向量右乘矩阵，这个Transform的累积过程就是C=Mbone*Mfather*Mgrandpar*...*Mroot）,得到该骨骼在世界空间上的变换矩阵 - Combined TransformMatrix，即通过这个矩阵可将顶点从骨骼空间变换到世界空间。那么这个矩阵的逆矩阵就可以将世界空间中的顶点变换到某块骨骼的骨骼空间。由于Mesh实际上就是定义在世界空间了，所以这个逆矩阵就是OffsetMatrix。即Offset Matrix就是骨骼在初始位置（没有经过任何动画改变）时将bone变换到世界空间的矩阵（CombinedTransformMatrix）的逆矩阵，有一些资料称之为Inverse Matrix。在几何流水线中，是通过变换矩阵将顶点变换到上层空间，最终得到世界坐标，逆矩阵则做相反的事，所以Inverse这种提法也符合惯例。那么Offset这种提法从字面上怎么理解呢？Offset即骨骼相对于世界原点的偏移，世界原点加上这个偏移就变成骨骼空间的原点，同样定义在世界空间中的点经过这个偏移矩阵的作用也被变换到骨骼空间了。从另一角度理解，在动画中模型中顶点的位置是根据骨骼位置动态计算的，也就是说顶点跟着骨骼动，但首先必须确定顶点和骨骼之间的相对位置（即顶点在该骨骼坐标系中的位置），一个骨骼可能对应很多顶点，如果要保存这个相对位置每个顶点对于每块受控制的骨骼都要保存，这样就要保存太多的矩阵了。。。所以只保存mesh空间到骨骼空间的变换（即OffsetMatrix），然后通过这个变换计算每个顶点在该骨骼空间中的坐标，所以OffsetMatrix也反应了mesh和每块骨骼的相对位置，只是这个位置是间接的通过和世界坐标空间的关系表达的，在初始位置将骨骼按照模型的形状摆好是关键之处。

以上的分析是通过将mesh space和world space重合得到OffsetMatrix的计算方法。那么如果他们不重合呢？那就要先计算顶点从mesh space变换到world space的变换矩阵，并乘上（还是右乘为例）Combined Matrix的InverseMatrix从而得到OffsetMatrix。但是这不是找麻烦吗？因为Mesh的原点在哪儿并不重要，为啥不让他们重合呢？

还有一个问题是，既然OffsetMatrix可以计算出来，为啥还要在骨骼动画文件中同时提供TransformMatrix和OffsetMatrix呢？实际上文件中确实可以不提供OffsetMatrix，而只在载入时计算。但TransformMatrix不可缺少，动画关键帧数据一般只存储骨骼的旋转和根骨骼的位置，骨骼间的相对位置还是要靠TransformMatrix提供。在微软的X文件结构中提供了OffsetMatrix，原因是什么呢？我不知道。我猜想一个可能的原因是为了兼容性和灵活性，比如mesh并没有定义在世界坐标系，而是作为一个object放置在3d max中，在导出骨骼动画时不能简单的认为mesh的顶点坐标是相对于世界原点的，还要把这个object的位置考虑进去，于是导出插件要计算出OffsetMatrix并保存在x文件中以避免兼容性问题。

关于OffsetMatrix和TransformMatrix含有平移，旋转和缩放的讨论：

首先，OffsetMatrix取决于骨骼的初始位置(即TransformMatrix)，由于骨骼动画中我们使用的是动画中的位置，初始位置是什么样并不重要，所以可以在初始位置中只包含平移，而旋转和缩放在动画中设置（一般也仅仅使用旋转，这也是为啥动画通常中可以用一个四元数表示骨骼的关键帧）。在这种情况下，OffsetMatrix只包含平移即可。因此一些引擎的Bone中不存放Transform矩阵，而只存放骨骼在父骨骼空间中的坐标，然后旋转只在动画帧中设置，最基本的骨骼动画即可实现。但也可在Transform和Offset Matrix中包括旋转和缩放，这样可以提高创建动画时的容错性。

在本文DEMO中，我们也没有使用矩阵保存Bone Offset，而只用了一个坐标保存偏移位置。





参考链接：

https://blog.csdn.net/QFire/article/details/80016402