###### 设计模式原则

- 单一职责：  一个类只负责一个功能领域中相应的职责
- 开闭原则：  扩展开发，修改关闭
- 里氏替换： 引用基类的对象能透明的使用其子类  （使用基类来对对象定义，运行中再确定子类类型。）
- 依赖倒转：抽象不应该依赖细节，细节应该依赖于抽象  （针对接口编程，而不是针对实现编程）
- 接口隔离：使用多个接口，而不是使用单一的总接口
- 合成复用：  尽量使用对象的组合，而不是继承来达到复用
- 迪米特法则：一个实体应当尽可能少的于其他实体发生相互作用。（this本身，参数、成员对象（集合中所有），当前对象所创建的对象）

##### 设计模式

=================================================创建型===========================================

**单例模式模式**     ————  确保对象唯一性        ★★★★

​		确保对象在整个程序的生命周期的唯一性。  一些管理器类进程会用到单例

**简单工厂模式**     ————  集中式工厂的实现		 ★★★★

工厂角色   抽象产品  具体产品j

 使用场景：AI节点类的创建      事件子类的创建

**工厂方法模式**      ————    多态工厂方法的实现

抽象工厂  具体工厂   抽象产品  具体产品  

定义一个创建对象的接口，让子类决定决定将哪一个类实例化		     完全符合开闭原则

使用场景：

**抽象工厂模式**     ————   产品族的创建

抽象工厂  具体工厂   抽象产品  具体产品  

提供一个创建一系列相关或相互依赖对象的接口      完全符合开闭原则

使用场景：界面皮肤库 （Spring系列组件  Summer系列组件）

**原型模式模式**     ————  对象的克隆

抽象

**建造者模式**     ————  复杂对象的组装于创建

抽象原型   具体原型

使用场景：.Net   ICloneable 

**建造者模式**     ————  复杂对象的组装与创建

抽象建造者  具体创建者   产品 （创建比较复杂）  指导者

将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表示。



============================================结构型================================================

**适配器模式**     ————  不兼容结构的协调   ( 别名包装器  Wrapper )

目标抽象类 Target   适配器类Adapter   适配者类Adaptee

将接口转换成客户希望的另一个接口，使接口不兼容的哪些类可以一起工作



**桥接模式**     ————  处理多维度变化

抽象类    扩充抽象类   实现类接口   具体实现类

将抽象部分与实现部分隔离，是他们都可以独立的变化

使用场景：毛笔（大中小）颜色（红绿蓝）  



**组合模式**     ————  树形结构的处理  ★★★★

抽象构建    叶子构建（leaf）   容器构建(composite) 

使用场景：AI 行为树的实现    文件文件夹的遍历  Unity的Component的设计



**装饰者**   ————  扩展系统功能

抽象构建  具体构建  抽象装饰类具体装饰类

动态的给给一个对象增加一些额外的职责

使用场景：一个数据先简单加密，然后二次加密 ，三次加密。



**外观者模式**     ————  提供统一的入口 ★★★★

外观角色   子系统角色

外部与一个子系统的通信，通过一个统一的外观角色进行

使用场景 ：之前使用过的一个uLua框架 MVC。有很多管理器（），提供一个Facade 统一去获取管理类  



享元模式     ————  实现对象的复用

**代理模式**     ————  对象的间接访问★★★★

抽象主题  代理主题  真实主题角色          （远程代理、虚拟代理、保护代理、缓存代理）

给一个对象提供一个代理，并由代理对象控制对原对象的引用



**享元模式**  ————  实现对象的复用

对象池的设计



============================================行为型================================================

**职责链模式**     ————  请求的链式处理

**命令模式**     ————  请求发送者与接收者的解耦

**解释器模式**     ————  自定义语言的实现

**迭代模式**     ————  遍历聚合对象中的元素  ★★★★

抽象迭代器  具体迭代器  抽象聚合类  具体聚合

提供一个方法来访问聚合对戏，而不是暴露这个对象的内部表现

应用场景：IEnumerable   IEnumurator   的实现 



**中介者模式**     ————  协调多个对象直接的交互  ★★★★

抽象中介者   具体中介者  抽象同事  具体同事

将一个网状结构的关联，转换成一个星形的关联

应用场景：中介者/同事   好友/QQ群  PureMvc的View交互的实现



**备忘录模式**     ————  撤销功能的实现

**观察者模式**（订阅发布者）     ————  对象间的联动             ★★★★          

目标 （Subject） 具体目标   观察者  具体观察者

对象直接的一种一对多的依赖关系

应用场景：Socket 消息分发处理（单机版/网络版）->观察者  接收的消息数据（目标）具体派发

​				   .Net 的事件也有种这样的味道

​					事件系统EventManager  Laya的EventHandler



**状态模式**     ————  对象状态及其装换    ★★★★

环境类    抽象状态   具体状态

应用场景：Unity Animator系统        世界2/3 状态机的实现（OnInit  OnEnter  OnUpdate OnExit ..）



**策略模式**     ————  算法的封装于切换



**模板方法模式**     ————  定义算法的框架

**访问者模式**     ————  操作复杂对象结构









##### 算法

[排序]: https://www.cnblogs.com/onepixel/articles/7674659.html



![image-20200606230517260](G:\新建文件夹\MD\MD插图\image-20200606230517260.png)

### 冒泡排序（Bubble Sort）

- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到排序完成。

### 选择排序（Selection Sort）

- 初始状态：无序区为R[1..n]，有序区为空；
- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
- n-1趟结束，数组有序化了。

### 插入排序（Insertion Sort）

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤2~5。



### 快速排序（Quick Sort）（分治法）

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

- 从数列中挑出一个元素，称为 “基准”（pivot）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

### 希尔排序（Shell Sort）

- 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
- 按增量序列个数k，对序列进行k 趟排序；
- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 堆排序（Heap Sort）（二叉树）

- 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
- 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
- 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

### 计数排序（Counting Sort）

- 找出待排序的数组中最大和最小的元素；
- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

### 桶排序（Bucket Sort）

- 设置一个定量的数组当作空桶；
- 遍历输入数据，并且把数据一个一个放到对应的桶里去；
- 对每个不是空的桶进行排序；
- 从不是空的桶里把排好序的数据拼接起来。 

### 基数排序（Radix Sort）

- 取得数组中的最大数，并取得位数；
- arr为原始数组，从最低位开始取每个位组成radix数组；
- 对radix进行计数排序（利用计数排序适用于小范围数的特点）；

### 归并排序（Merge Sort）

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。





[算法在线测试]: https://www.nowcoder.com/ta/coding-interviews

1. 行为树   AI行为树

   

2. 二叉树

3. 四叉树   https://www.cnblogs.com/sevenyuan/p/7193654.html

   正如其名，四叉树就是每个父节点都具有四个子节点的树状[数据结构](http://lib.csdn.net/base/31)。由于要区分屏幕上的物体，我们要将屏幕划分为**四个区域**，所以四叉树的四个节点正合适表示这四个区域。

   屏幕上四个区域分别为：左上区域 + 右上区域 + 右下区域 + 左下区域，方便起见，我们分别命名为：象限1、象限2、象限3、象限4：



```js
/* 
  四叉树节点包含：
  - objects: 用于存储物体对象
  - nodes: 存储四个子节点
  - level: 该节点的深度，根节点的默认深度为0
  - bounds: 该节点对应的象限在屏幕上的范围，bounds是一个矩形
*/
var QuadTree = function QuadTree(bounds, level) {
    this.objects = [];
    this.nodes = [];
    this.level = typeof level === 'undefined' ? 0 : level;
    this.bounds = bounds;   	 
}
//getIndex 获取物体对应的象限序号    split 继续空间划分   insert 插入功能：  retrieve 筛选功能，帅选出可能发生碰撞的集合
```

1. 八叉树

   三维空间划分的碰撞检测

2. A*算法

   **A \***是Dijkstra’s算法的变形

   F=G（到底目标最短步数）+H（原点到达当前位置的步数）

3. 将初始节点放入到open列表中。

4. 判断open列表。如果为空，则搜索失败。如果open列表中存在目标节点，则搜索成功。

5. 从open列表中取出F值最小的节点作为当前节点，并将其加入到close列表中。

6. 计算当前节点的相邻的所有可到达节点，生成一组子节点。对于每一个子节点：
   - 如果该节点在close列表中，则丢弃它
   - 如果该节点在open列表中，则检查其通过当前节点计算得到的F值是否更小，如果更小则更新其F值，并将其父节点设置为当前节点。
   - 如果该节点不在open列表中，则将其加入到open列表，并计算F值，设置其父节点为当前节点。

7. 转到2步骤

​     优化：OpenList 用二叉堆，插入排序和取值速度方便  logn

​				设置最大深度，防止递归太深；

​				分帧计算

​				辅助导航点

​				





##### 数学知识



