-- 变量-----------------------------------
_LightColor0                   灯光颜色
_WorldSpaceLightPos0            世界空间光源的位置
_WorldSpaceCameraPos           世界空间相机的位置
unity_ObjectToWorld            模型到世界 
unity_WorldToObject            世界到模型

-- 宏  -----------------------------------
UNITY_LIGHTMODEL_AMBIENT       环境光
UNITY_MATRIX_MVP               模型空间-》裁剪空间
TRANSFORM_TEX                  计算经过平铺和偏移后的纹理坐标
TANGENT_SPACE_ROTATION         模型空间 -》法线空间 预编译成下面代码
// float3 binormal = cross(normalize(v.normal),normalize(v.tangent.xyz)) * v.tangent.w; 
// float3x3 rotation= float3x3(v.tangent.xyz,binormal,v.normal);


--方法-------------------------------------
mul(matrix,向量)  将向量从A空间变换到另外B空间
mul(向量,matrix)  将向量从B空间变换到另外A空间
saturate(num)     控制在>0
ObjSpaceLightDir(objectPos)        返回模型坐标系的光照方向
ObjSpaceViewDir(objectPos)         返回模型坐标系的观察方向
UnityWorldSpaceLightDir(worldpos)  返回关照方向   _WorldSpaceLightPos0 - i.worldPos
UnityWorldSpaceViewDir(worldpos)   返回观察方向   _WorldSpaceCameraPos - i.worldPos
UnityObjectToWorldNormal(normal)   模型空间的法线装换成世界空间的法线  /mul(_Object2World,v.normal);
UnpackNormal(packedNormal)         将 normal map 存储的法线纹理 映射回法线方向  纹素值  映射到 法线方向
tex2D(_MainTex,i.uv)               对纹理进行采集   参数1：需要被采集的纹理  参数2 ： 纹理坐标  return 纹素值
void clip(float0~4)                参数：裁剪时使用的标量和适量   ，任何一个分量为负数，舍弃当前像素的输出颜色


-- 笔记---------------------------------------
基础光照模型 : 自发光(emissive) + 环境光(ambient)  + 漫反射(diffuse) + 高亮反射(specular)

漫反射(diffuse)   n 法线  l 入射光线
C_diffuse = (C_light * M_diffuse) * max(0,n.l);
半兰伯特模型(Half Lambert) 一般模式为 A= 0.5   B = 0.5
C_diffuse = (C_light * M_diffuse) * (A(n.l) + B)

高亮反射(specular) 
1.  Phong模型 v 观察方向 r 发射光线  gloss 光泽度
C_specular = (C_light * M_specular ) * pow( max(0,v.r),gloss)

1. Blinn模型  n 法线  h = v+l
C_specular = (C_light * M_specular ) *pow(  max(0,n.h),gloss)

